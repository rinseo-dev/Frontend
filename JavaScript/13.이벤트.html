<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>13.이벤트</title>
  <style>
    .area{
      border : 1px solid;
      height: 200px;
    }
  </style>
</head>
<body>
  <h1>이벤트(event)</h1>
  <h2>1. 이벤트 모델 종류</h2>
  <p>
    특정 요소 객체를 가지고 와서 해당 요소의 이벤트 속성에 접근한 후 이벤트 핸들러를 연결하는 방식<br>
    이벤트를 제거할 수 있음
  </p>

  <button id="btn1">실행확인</button>
  <button id="btn2">실행확인(제거)</button>
  <div id="area1" class="area"></div>
  <script>
    const area1 = document.getElementById("area1");

    /* 같은 기능이라 이건 주석
    const btn1 = document.getElementById("btn");
    btn1.onclick = function(){ // 이벤트 핸들러
    }*/

    document.getElementById("btn1").onclick = function(){
      area1.innerHTML += "btn1이 클릭되었습니다.<br>";
    }

    document.getElementById("btn2").onclick = function(){
      document.getElementById("btn1").onclick = null; // 이벤트 제거 방법 - 클릭시 null로
      area1.innerHTML += "btn1의 이벤트가 제거됨<br>";
    }
    // 제거버튼을 누르고 나서 다시 실행확인을 눌러도 실행되지 않음. 제거 된 값으로 바뀐 상태.
  </script>

  <h3>* 인라인 이벤트 모델</h3>
  <p>
    요소내부에 직접적으로 이벤트 속성을 넣어 실행할 내용을 정의하는 방식<br>
    주로 script태그 내에 정의되어 있는 함수 호출하는 방식 선호<br>
  </p>
  <!--인라인 방식-->
  <button onclick="document.getElementById('area2').innerHTML+='첫번째 버튼 클릭<br>';">실행확인</button>
  
  <!--기존방식-->
  <button onclick="test1();">실행확인</button> 
  <div id="area2" class="area"></div>
  <script>
    function test1(){ // 기존방식
      document.getElementById("area2").innerHTML += "두번째 버튼 클릭<br>"; 
    }
  </script>

  <br>

  <h3>* addEventListener에 등록</h3>
  <p>
    W3C에서 공식적으로 지정한 이벤트 모델
  </p>
  
  <button id="btn3">실행확인</button>
  <script>
    const btn3 = document.getElementById("btn3");

    // 이벤트 걸고자 하는 요소 객체.addEventListener("이벤트명",이벤트핸들러);
    btn3.addEventListener("click",function(){ // on안붙여도 됨 이벤트 이름인 click만 입력
      alert("WC3공식 이벤트 핸들러 테스트");
    });

    // 마우스가 버튼 요소에 들어올 때 - 마우스포인터가 요소 안에 들어오면 mouse enter,나가면 mouse out
    btn3.addEventListener("mouseenter", function(){ // 경계를 지나서 안의 요소로 들어왔을 때
      btn3.style.backgroundColor = "pink";
    });

    btn3.addEventListener("mouseout",function(){ // 요소 경계 밖으로 나갔을 때
      btn3.style.backgroundColor = "yellow";
    });
  </script>

  <hr>

  <h2>2. 현재 이벤트가 발생한 해당 요소 객체에 접근하는 방법</h2>
  <button id="btn4">이벤트 속성에 핸들러 바인딩</button>
  <button id="btn5">addEventListener 방식</button>

  <button onclick="test2();">인라인방식</button>
  <button onclick="test2(this);">인라인방식2</button>

  <script>
    // 기본 이벤트 방식
    // function(e) : e => 이벤트 핸들러를 의미함
    document.getElementById('btn4').onclick = function(e){
      // console.log(e); // 콘솔창에서 PointerEvent 상세보기 - type:click 클릭이 발생했다는 의미
      // target : button#btn4 버튼 4가 타겟이 됨. 결과적으로 btn4가 클릭됐다는걸 볼 수 있음
      console.log(window.event);

      // 현재 이벤트가 발생한 요소객체에 접근하고자 하면 아래 방법들이 있음.
      console.log(e.target); // 가장 많이 사용되는 방법
      console.log(window.event.target); // e값을 안받았을 경우 이렇게 보면 됨.
      console.log(this); // 타겟이 된 '나 자신'의 객체를 볼 수 있음

      // 현재 이벤트에 동적인 효과를 주는 방법 - 요소 접근 방법 모두 사용할 수 있음
      e.target.innerHTML = "버튼클릭됨";
      window.event.target.style.backgroundColor = "red";
      this.style.color = "white";

      // e.target, window.event.target, this 중 골라서 사용
    } 
  </script>
</body>
</html>